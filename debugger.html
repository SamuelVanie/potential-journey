<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-07-02 Tue 23:38 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
</head>
<body>
<div id="content" class="content">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org4b6bced">1. How I wrote the vdebugger, a debugger in Rust for Linux Programs ?</a>
<ul>
<li><a href="#orgd1d30ab">1.1. Setting Up the Development Environment</a></li>
<li><a href="#org9df2197">1.2. Laying the Groundwork</a></li>
<li><a href="#org0a3a852">1.3. Implementing Basic Debugger Functionality</a>
<ul>
<li><a href="#org13d4b3c">1.3.1. Process Creation and Control</a></li>
<li><a href="#org851b303">1.3.2. The Debugger Struct</a></li>
<li><a href="#org2195c27">1.3.3. The Run Function</a></li>
<li><a href="#orgc553ae9">1.3.4. Command Handling</a></li>
<li><a href="#orgb46e574">1.3.5. Implementing Commands</a></li>
<li><a href="#org87832f1">1.3.6. Challenges and Learnings</a></li>
</ul>
</li>
<li><a href="#orgffd0340">1.4. Conclusion</a></li>
<li><a href="#orga0bc506">1.5. References</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org4b6bced" class="outline-2">
<h2 id="org4b6bced"><span class="section-number-2">1.</span> How I wrote the vdebugger, a debugger in Rust for Linux Programs ?</h2>
<div class="outline-text-2" id="text-1">
<p>
As a passionate developer always looking to expand my skills, I recently embarked on an exciting project: creating a debugger in Rust for Linux programs. This article chronicles my journey, from setting up a reproducible development environment to implementing the core functionality of the debugger.
</p>

<p>
You can check the project at : <a href="https://github.com/SamuelVanie/vdebugger">the vdebugger repo</a>
</p>
</div>
<div id="outline-container-orgd1d30ab" class="outline-3">
<h3 id="orgd1d30ab"><span class="section-number-3">1.1.</span> Setting Up the Development Environment</h3>
<div class="outline-text-3" id="text-1-1">
<p>
I began by creating a robust and reproducible development environment using Nix.
Here's how I set it up&#x2026;
</p>

<p>
It's a classic flake.nix file that contains
</p>

<ol class="org-ol">
<li><code>flake-utils</code> to automatically generate outputs and devShells for various systems</li>
<li>Employed <code>rust-overlay</code> to pull the latest Rust version directly.</li>
</ol>

<p>
That's all ! The final nix file looks like this :
</p>

<div class="org-src-container">
<pre class="src src-nix">{
  description = "A nix file for my homemade debugger";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-24.05";
    flake-utils.url = "github:numtide/flake-utils";
    rust-overlay.url = "github:oxalica/rust-overlay";
  };

  outputs = { self, nixpkgs, flake-utils, rust-overlay, ... }:
    flake-utils.lib.eachDefaultSystem (system:
      let
	overlays = [ (import rust-overlay) ];
	pkgs = import nixpkgs { inherit system overlays; };
	rustVersion = pkgs.rust-bin.stable.latest.default;

	rustPlatform = pkgs.makeRustPlatform {
	  cargo = rustVersion;
	  rustc = rustVersion;
	};

	vdebuggerBuild = rustPlatform.buildRustPackage {
	  pname = "vdebugger";
	  version = "0.1.0";
	  src = ./.;
	  cargoLock.lockFile = ./Cargo.lock;
	};

      in
      {
	defaultPackage = vdebuggerBuild;

	devShell = pkgs.mkShell {
	  buildInputs = [ (rustVersion.override { extensions = [ "rust-src" ]; }) ];
	};

      });
}
</pre>
</div>

<p>
To run the project and start programming I simply the command <code>nix develop</code> that permits to access my devShell.
</p>
</div>
</div>
<div id="outline-container-org9df2197" class="outline-3">
<h3 id="org9df2197"><span class="section-number-3">1.2.</span> Laying the Groundwork</h3>
<div class="outline-text-3" id="text-1-2">
<p>
With the environment ready, I dove into the core concepts of debugger development. I quickly realized that a debugger operates as a parent process controlling a child process(the debugee). This led me to search for a Rust crate that could provide functionality similar to the C <code>fork()</code> system call.
</p>

<p>
My search led me to the <code>nix</code> crate, which offers Rust bindings for many POSIX APIs, including most C system call functions. This crate became instrumental in my project
</p>
</div>
</div>
<div id="outline-container-org0a3a852" class="outline-3">
<h3 id="org0a3a852"><span class="section-number-3">1.3.</span> Implementing Basic Debugger Functionality</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-org13d4b3c" class="outline-4">
<h4 id="org13d4b3c"><span class="section-number-4">1.3.1.</span> Process Creation and Control</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
In my main function, I implemented the following steps:
</p>

<ol class="org-ol">
<li>Created a new process using the <code>fork()</code> function from the <code>nix</code> crate.</li>
<li>Used the <code>traceme()</code> function (equivalent to the <code>ptrace(PTRACE_TRACEME, ...)</code> in C) to permit to the parent function to trace the child.</li>
<li>Executed the program to be debugged in the child process using the <code>execv()</code> function.</li>
</ol>
</div>
</div>
<div id="outline-container-org851b303" class="outline-4">
<h4 id="org851b303"><span class="section-number-4">1.3.2.</span> The Debugger Struct</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
To organize the debugger's functionality and have a better management of the parent process flow, I created a <code>Debugger</code> struct. The fields of this struct are :
</p>
<ul class="org-ul">
<li><code>m_prog_name</code>: The name of the program being debugged</li>
<li><code>m_pid</code> : The process ID of the child process we're controlling</li>
</ul>
</div>
</div>
<div id="outline-container-org2195c27" class="outline-4">
<h4 id="org2195c27"><span class="section-number-4">1.3.3.</span> The Run Function</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
The heart of our debugger is the <code>run</code> function. Here's how it operates:
</p>

<ol class="org-ol">
<li>It waits for the child process to start using the <code>waitpid</code> function from the <code>nix</code> crate.
This ensures that we don't begin debugging until the child process is ready.</li>

<li>Once the child process is running, it creates a command-line prompt using the <code>linefeed</code> crate. This crate not only handles user input but also provides history functionality, enhancing the user experience.</li>
</ol>
</div>
</div>
<div id="outline-container-orgc553ae9" class="outline-4">
<h4 id="orgc553ae9"><span class="section-number-4">1.3.4.</span> Command Handling</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
To manage the various debugging commands, I implemented the following system:
</p>

<ol class="org-ol">
<li>Created an enum called <code>Command</code> with variants representing different debugging actions (e.g., continue, step, breakpoint).</li>
<li>Utilized the <code>strum_macros</code> crate to easily translate string input from the prompt into the corresponding <code>Command</code> variant.</li>
<li>Implemented a <code>handle_command</code> function that:
<ul class="org-ul">
<li>Attempts to parse the user input into a <code>Command</code> variant</li>
<li>If successful, calls the appropriate functino for that command</li>
<li>If the input doesn't match any know command, it informs the user that the command doesn't exist</li>
</ul></li>
</ol>

<p>
This approach provides a flexible and extensible way to add new debugging commands in the future.
</p>
</div>
</div>
<div id="outline-container-orgb46e574" class="outline-4">
<h4 id="orgb46e574"><span class="section-number-4">1.3.5.</span> Implementing Commands</h4>
<div class="outline-text-4" id="text-1-3-5">
</div>
<ol class="org-ol">
<li><a id="org52fc54f"></a>Continue<br />
<div class="outline-text-5" id="text-1-3-5-1">
<p>
When the user enters the "continue" command, <code>handle_command</code> recognizes it and calls the <code>continue</code> command. The continue function uses the <code>cont</code> function from the nix crate to send a CONTINUE instruction to the debuggee program with its pid.
</p>

<p>
This allows the debugged program to continue execution until the next breakpoint or until it terminates.
</p>
</div>
</li>
<li><a id="org4e96903"></a>break<br />
<div class="outline-text-5" id="text-1-3-5-2">
<p>
Will come soon&#x2026;
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-org87832f1" class="outline-4">
<h4 id="org87832f1"><span class="section-number-4">1.3.6.</span> Challenges and Learnings</h4>
<div class="outline-text-4" id="text-1-3-6">
<p>
Developing this debugger presented several challenges:
</p>

<ol class="org-ol">
<li>Understanding the intricacies of process control and the ptrace system call.</li>
<li>Mapping C concepts and functinos to their Rust equivalents.</li>
<li>Implementing a robust command parsing and handling system.</li>
</ol>

<p>
However, shese challenges provided valuable learning experiences. I gained a deeper understanding of:
</p>

<ul class="org-ul">
<li>Low-level system interactions in Rust</li>
<li>The architecture of debugging tools</li>
<li>Effective use of Rust crates to simplify complex tasks</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgffd0340" class="outline-3">
<h3 id="orgffd0340"><span class="section-number-3">1.4.</span> Conclusion</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Creating a debugger in Rust for Linux programs has been an enlightening journey. It has deepened my understanding of both Rust and the underlying mechanics of debugging tools. The project showcases the power of Rust in systems programming, demonstrating how it can be used to create robust, safe, and efficient tools for low-level system interactions.
</p>

<p>
This experience has not only improved my Rust programming skills but also given me a newfound appreciation for the complexity and ingenuity behind the development tools we use every day.
</p>
</div>
</div>
<div id="outline-container-orga0bc506" class="outline-3">
<h3 id="orga0bc506"><span class="section-number-3">1.5.</span> References</h3>
<div class="outline-text-3" id="text-1-5">
<p>
<a href="https://blog.tartanllama.xyz/writing-a-linux-debugger-setup/">Writing a linux debugger setup</a>
</p>

<p>
<a href="https://docs.rs/nix/latest/nix/index.html">nix crate documentation</a>
</p>

<p>
<a href="https://docs.rs/strum/latest/strum/">strum crate documentation</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2024-07-02 Tue 23:38</p>
</div>
</body>
</html>
