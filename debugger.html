<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-01-02 Thu 05:26 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/search.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/search.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
</head>
<body>
<div id="content" class="content">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org89702a6">1. How I wrote the vdebugger, a debugger in Rust for Linux Programs ?</a>
<ul>
<li><a href="#orgd0a86dd">1.1. Setting Up the Development Environment</a></li>
<li><a href="#orgf7f0789">1.2. Laying the Groundwork</a></li>
<li><a href="#org5a92c9a">1.3. Implementing Basic Debugger Functionality</a>
<ul>
<li><a href="#orgfda11f0">1.3.1. Process Creation and Control</a></li>
<li><a href="#orge7e98b1">1.3.2. The Debugger Struct</a></li>
<li><a href="#org09a3332">1.3.3. The Run Function</a></li>
<li><a href="#org414a91f">1.3.4. Command Handling</a></li>
<li><a href="#org5703510">1.3.5. Implementing Commands</a></li>
</ul>
</li>
<li><a href="#org6b1d144">1.4. Conclusion</a></li>
<li><a href="#org9c682ff">1.5. References</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org89702a6" class="outline-2">
<h2 id="org89702a6"><span class="section-number-2">1.</span> How I wrote the vdebugger, a debugger in Rust for Linux Programs ?</h2>
<div class="outline-text-2" id="text-1">
<p>
As a passionate developer always looking to expand my skills, I recently embarked on an exciting project: creating a debugger in Rust for Linux programs. This article chronicles my journey, from setting up a reproducible development environment to implementing the core functionality of the debugger.
</p>

<p>
You can check the project at : <a href="https://github.com/SamuelVanie/vdebugger">the vdebugger repo</a>
</p>
</div>
<div id="outline-container-orgd0a86dd" class="outline-3">
<h3 id="orgd0a86dd"><span class="section-number-3">1.1.</span> Setting Up the Development Environment</h3>
<div class="outline-text-3" id="text-1-1">
<p>
I began by creating a robust and reproducible development environment using Nix.
Here's how I set it up&#x2026;
</p>

<p>
It's a classic flake.nix file that contains
</p>

<ol class="org-ol">
<li><code>flake-utils</code> to automatically generate outputs and devShells for various systems</li>
<li>Employed <code>rust-overlay</code> to pull the latest Rust version directly.</li>
</ol>

<p>
That's all ! The final nix file looks like this :
</p>

<div class="org-src-container">
<pre class="src src-nix">{
  description = "A nix file for my homemade debugger";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-24.05";
    flake-utils.url = "github:numtide/flake-utils";
    rust-overlay.url = "github:oxalica/rust-overlay";
  };

  outputs = { self, nixpkgs, flake-utils, rust-overlay, ... }:
    flake-utils.lib.eachDefaultSystem (system:
      let
	overlays = [ (import rust-overlay) ];
	pkgs = import nixpkgs { inherit system overlays; };
	rustVersion = pkgs.rust-bin.stable.latest.default;

	rustPlatform = pkgs.makeRustPlatform {
	  cargo = rustVersion;
	  rustc = rustVersion;
	};

	vdebuggerBuild = rustPlatform.buildRustPackage {
	  pname = "vdebugger";
	  version = "0.1.0";
	  src = ./.;
	  cargoLock.lockFile = ./Cargo.lock;
	};

      in
      {
	defaultPackage = vdebuggerBuild;

	devShell = pkgs.mkShell {
	  buildInputs = [ (rustVersion.override { extensions = [ "rust-src" ]; }) ];
	};

      });
}
</pre>
</div>

<p>
To run the project and start programming I simply the command <code>nix develop</code> that permits to access my devShell.
</p>

<p>
The rust overlay feature permit to automatically build a rust development platform with cargo and the rust compiler.
Pinning the nix version to the 24 permit to always pull the same version of the rust compiler which is the 1.79 in this case.
</p>
</div>
</div>
<div id="outline-container-orgf7f0789" class="outline-3">
<h3 id="orgf7f0789"><span class="section-number-3">1.2.</span> Laying the Groundwork</h3>
<div class="outline-text-3" id="text-1-2">
<p>
With the environment ready, I dove into the core concepts of debugger development. I quickly realized that a debugger operates as a parent process controlling a child process(the debugee). This led me to search for a Rust crate that could provide functionality similar to the C <code>fork()</code> system call.
</p>

<p>
My search led me to the <code>nix</code> crate, which offers Rust bindings for many POSIX APIs, including most C system call functions. This crate became instrumental in my project
</p>
</div>
</div>
<div id="outline-container-org5a92c9a" class="outline-3">
<h3 id="org5a92c9a"><span class="section-number-3">1.3.</span> Implementing Basic Debugger Functionality</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-orgfda11f0" class="outline-4">
<h4 id="orgfda11f0"><span class="section-number-4">1.3.1.</span> Process Creation and Control</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
In my main function, I implemented the following steps:
</p>

<ol class="org-ol">
<li>Created a new process using the <code>fork()</code> function from the <code>nix</code> crate.</li>
<li>Used the <code>traceme()</code> function (equivalent to the <code>ptrace(PTRACE_TRACEME, ...)</code> in C) to permit to the parent function to trace the child.</li>
<li>Executed the program to be debugged in the child process using the <code>execv()</code> function.</li>
</ol>
</div>
</div>
<div id="outline-container-orge7e98b1" class="outline-4">
<h4 id="orge7e98b1"><span class="section-number-4">1.3.2.</span> The Debugger Struct</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
To organize the debugger's functionality and have a better management of the parent process flow, I created a <code>Debugger</code> struct. The fields of this struct are :
</p>
<ul class="org-ul">
<li><code>prog_name</code>: The name of the program being debugged</li>
<li><code>pid</code> : The process ID of the child process we're controlling</li>
</ul>
</div>
</div>
<div id="outline-container-org09a3332" class="outline-4">
<h4 id="org09a3332"><span class="section-number-4">1.3.3.</span> The Run Function</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
The heart of our debugger is the <code>run</code> function. Here's how it operates:
</p>

<ol class="org-ol">
<li>It waits for the child process to start using the <code>waitpid</code> function from the <code>nix</code> crate.
This ensures that we don't begin debugging until the child process is ready.</li>

<li>Once the child process is running, it creates a command-line prompt using the <code>linefeed</code> crate. This crate not only handles user input but also provides history functionality, enhancing the user experience.</li>
</ol>
</div>
</div>
<div id="outline-container-org414a91f" class="outline-4">
<h4 id="org414a91f"><span class="section-number-4">1.3.4.</span> Command Handling</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
To manage the various debugging commands, I implemented the following system:
</p>

<ol class="org-ol">
<li>Created an enum called <code>Command</code> with variants representing different debugging actions (e.g., continue, step, break, &#x2026;).</li>
<li>Utilized the <code>strum_macros</code> crate to easily translate string input from the prompt into the corresponding <code>Command</code> variant. (a command break/Break/BREAK/bReak is translated without taking into account the case to the variant BREAK)</li>
<li>Implemented a <code>handle_command</code> function that:
<ul class="org-ul">
<li>Attempts to parse the user input into a <code>Command</code> variant (like in the point 2)</li>
<li>If successful, calls the appropriate function for that command</li>
<li>If the input doesn't match any know command, it informs the user that the command doesn't exist</li>
</ul></li>
</ol>

<p>
This approach provides a flexible and extensible way to add new debugging commands in the future.
</p>
</div>
</div>
<div id="outline-container-org5703510" class="outline-4">
<h4 id="org5703510"><span class="section-number-4">1.3.5.</span> Implementing Commands</h4>
<div class="outline-text-4" id="text-1-3-5">
</div>
<ol class="org-ol">
<li><a id="org8447841"></a>Continue<br />
<div class="outline-text-5" id="text-1-3-5-1">
<p>
When the user enters the "continue" command, <code>handle_command</code> recognizes it and calls the <code>continue</code> command. The continue function uses the <code>cont</code> function from the nix crate to send a CONTINUE instruction to the debuggee program with its pid. (PTRACE<sub>CONT</sub> request sent to the tracee)
</p>

<p>
This allows the debugged program to continue execution until the next breakpoint or until it terminates.
</p>
</div>
</li>
<li><a id="orga45c3de"></a>break<br />
<div class="outline-text-5" id="text-1-3-5-2">
<p>
A crucial feature of any debugger is the ability to set and manage breakpoints. In my implementation, I've created a Breakpoint structure that encapsulates all necessary information for each breakpoint. Let's delve into the details of how this is implemented and used within the debugger.
</p>
</div>
<ol class="org-ol">
<li><a id="orga2b2c95"></a>The brekpoint structure<br />
<div class="outline-text-6" id="text-1-3-5-2-1">
<p>
The Breakpoint structure contains the following fields:
</p>

<div class="org-src-container">
<pre class="src src-rust">pub struct Breakpoint {
    pid: Pid,
    addr: *mut c_void,
    saved_data: i64,
    enabled: bool,
}
</pre>
</div>


<ul class="org-ul">
<li>pid: The process ID of the debuggee.</li>
<li>addr: The memory address where the breakpoint is set.</li>
<li>saved<sub>data</sub>: The original byte of data at the breakpoint address.</li>
<li>enabled: A boolean flag indicating whether the breakpoint is currently active.</li>
</ul>

<p>
(It may be slightly different in the code because I used dependency injection to be able to test data retrieval).
</p>
</div>
</li>
<li><a id="orgd2bb129"></a>Setting a breakpoint<br />
<div class="outline-text-6" id="text-1-3-5-2-2">
<p>
The process of setting a breakpoint involves several steps:
</p>

<ol class="org-ol">
<li><b>User Input</b>: The debugger prompts the user to enter the address where they want to set a breakpoint, typically provided as a hexadecimal string.</li>

<li><p>
<b>Reading Original Data</b>: Before setting the breakpoint, the debugger reads the original instruction at the specified address using the <code>read</code> function, which corresponds to the <code>ptrace(PTRACE_PEEKDATA,...)</code> function in C.
</p>

<div class="org-src-container">
<pre class="src src-rust">let current_line = ptrace::read(self.pid, addr);
</pre>
</div></li>

<li><p>
<b>Inserting the Breakpoint</b>: The debugger replaces the least significant byte of the instruction with the int3 interrupt instruction (encoded as 0xCC). This sends a SIGTRAP signal to the process when executed.
</p>

<div class="org-src-container">
<pre class="src src-rust">let int3 = 0xcc;
let breakpoint_line = (current_line &amp; !0xff) | int3;
self.saved_data = (current_line &amp; 0xff) as i64;
</pre>
</div></li>

<li><p>
<b>Writing the Breakpoint</b>: The modified instruction is written back to the address using the write function from the nix crate.
</p>

<div class="org-src-container">
<pre class="src src-rust">ptrace::write(self.pid, addr as *mut c_void, breakpoint_line as *mut c_void);
</pre>
</div></li>
</ol>
</div>
</li>
<li><a id="org663b05a"></a>Disabling a Breakpoint<br />
<div class="outline-text-6" id="text-1-3-5-2-3">
<p>
The process of disabling a breakpoint essentially reverses the steps taken to set it:
</p>

<ol class="org-ol">
<li><p>
<b>Reading Current Data</b>: Read the current data at the breakpoint address.
</p>

<div class="org-src-container">
<pre class="src src-rust">let line = ptrace::read(self.pid, self.addr as *mut c_void)?;
</pre>
</div></li>

<li><p>
<b>Restoring Original Instruction</b>: Compute the restored line by combining the original saved byte with the rest of the current instruction.
</p>

<div class="org-src-container">
<pre class="src src-rust">let restored_line = (line &amp; !0xff) | self.saved_data as i64;
</pre>
</div></li>

<li><p>
<b>Writing Restored Data</b>: Write the restored instruction back to the address.
</p>

<div class="org-src-container">
<pre class="src src-rust">ptrace::write(self.pid, self.addr as *mut c_void, restored_line as *mut c_void)?;
</pre>
</div></li>
</ol>


<ol class="org-ol">
<li><b>Adjusting Program Counter</b>: After disabling the breakpoint, the program counter is adjusted to go back to the previous line, allowing execution to continue from the correct point.</li>
</ol>
</div>
</li>
<li><a id="orgc2fa3eb"></a>Software vs. Hardware Breakpoints<br />
<div class="outline-text-6" id="text-1-3-5-2-4">
<p>
This implementation uses software breakpoints, which offer several advantages:
</p>

<ol class="org-ol">
<li><b>Unlimited Breakpoints</b>: Unlike hardware breakpoints, which are limited in number by the CPU architecture, software breakpoints allow for an unlimited number of breakpoints.</li>

<li><b>Portability</b>: Software breakpoints work consistently across different hardware architectures.</li>

<li><b>Flexibility</b>: They can be easily set and unset dynamically during the debugging process.</li>
</ol>

<p>
While hardware breakpoints can be more efficient in some cases, their limited number (often 4 or 8 on most CPUs) makes them less suitable for complex debugging scenarios that require many breakpoints.
</p>
</div>
</li>
<li><a id="orgb0c0bfb"></a>Challenges and Considerations<br />
<div class="outline-text-6" id="text-1-3-5-2-5">
<p>
Implementing breakpoints in this way comes with several challenges:
</p>

<ol class="org-ol">
<li><b>Atomic Operations</b>: Ensuring that the process of reading, modifying, and writing instructions is atomic to prevent race conditions.</li>

<li><b>Instruction Alignment</b>: Careful handling is required to ensure that breakpoints are set at the beginning of instructions, especially in architectures with variable-length instructions.</li>

<li><b>Performance Impact</b>: Software breakpoints modify the program's code, which can impact performance, especially with many breakpoints.</li>

<li><b>Multi-threading</b> : Special care is needed when dealing with multi-threaded programs to ensure breakpoints work correctly across all threads.</li>

<li><b>Handling Signals</b> : Proper handling of the SIGTRAP signal is crucial for the debugger to function correctly.</li>
</ol>
</div>
</li>
</ol>
</li>
<li><a id="orga4f26e1"></a>register<br />
<div class="outline-text-5" id="text-1-3-5-3">
<p>
To enable the continuation of execution after hitting a breakpoint, it is essential to reset the program counter to the previous instruction. This involves implementing functionality to manipulate the registers of a program, particularly the program counter. 
</p>
</div>
<ol class="org-ol">
<li><a id="org5765802"></a>Register Functions Implementation<br />
<div class="outline-text-6" id="text-1-3-5-3-1">
<p>
The register module provides functionality to interact with the CPU registers of the debugged program. The key components are the Reg enum, the RegDescriptor struct, and functions to get, set, and manipulate register values.
</p>


<div class="org-src-container">
<pre class="src src-rust">#[derive(Debug, Clone, Copy, PartialEq, EnumString)]
#[strum(ascii_case_insensitive)]
pub enum Reg { /*...*/ }

#[derive(Debug, PartialEq, Clone, Copy)]
pub struct RegDescriptor { /*...*/ }

pub static REGISTERS_DESCRIPTORS: &amp;[RegDescriptor] = &amp;[ /*...*/ ];
</pre>
</div>


<ul class="org-ul">
<li><b>Reg</b> : enumerates all the registers available in the CPU</li>
<li><b>RegDescriptor</b> : contains metadata about each register, including its name and DWARF index.</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="orga78e424"></a>Key functions<br />
<div class="outline-text-7" id="text-1-3-5-3-1-1">
<ul class="org-ul">
<li><p>
<b>Register value getters and setters</b> :
</p>

<div class="org-src-container">
<pre class="src src-rust">pub fn get_register_value(pid: Pid, r: Reg) -&gt; Result&lt;u64, nix::Error&gt; { /*...*/ }
pub fn set_register_value(pid: Pid, r: Reg, value: u64) -&gt; Result&lt;(), nix::Error&gt; { /*...*/ }
</pre>
</div></li>
</ul>


<p>
These functions interact with the actual register values of the debugged process, permitting to modify their values or to retrieve them.
</p>

<ul class="org-ul">
<li><p>
<b>Another way of retrieving register value</b> :
</p>

<div class="org-src-container">
<pre class="src src-rust">pub fn get_register_value_from_dwarf_register(pid: Pid, reg_num: i32) -&gt; Result&lt;u64, nix::Error&gt; { /*...*/ }
</pre>
</div></li>
</ul>

<p>
This function permit to get the register value using its dwarf number.
</p>
</div>
</li>
</ol>
</li>
<li><a id="org39b71d4"></a>Modifying the debugger core logic<br />
<div class="outline-text-6" id="text-1-3-5-3-2">
<ul class="org-ul">
<li><p>
<b>Introducing a new step<sub>over</sub><sub>breakpoint</sub> function</b> :
</p>

<div class="org-src-container">
<pre class="src src-rust">fn step_over_breakpoint(&amp;mut self) { /*...*/ }
</pre>
</div></li>
</ul>

<p>
This function permits to step over a breakpoint. I start by moving back the program counter to the previous line (because the line where the breakpoint is needs to also be executed and the execution of the line with int3 interruption moves the program counter to the next line). Then I disable the breakpoint which restores the original lines where the breakpoint was (removing the int3 instruction). I finally send a step signal to the debuggee and at the end of the program when the main debugger program takes the control back, I re-enable the breakpoint.
</p>

<ul class="org-ul">
<li><p>
<b>Modifying the continue<sub>execution</sub> function</b> :
</p>

<p>
To perform the correct logic, I've added a call to the step<sub>over</sub><sub>breakpoint</sub> function in the beginning ot the continue<sub>execution</sub>. Because the step<sub>over</sub><sub>breakpoint</sub> perform verification about the existence of a breakpoint before applying its logic this doesn't affect the code in case there's no breakpoints.
</p></li>

<li><p>
<b>Adding new register manipulation commands</b> :
</p>

<p>
To be able to manipulate registers in the debugger, I introduced new commands like <code>register read</code> (to get a particular register value), <code>register write</code> (to set a particular register value), and <code>register dump</code> (to display all registers values).
</p></li>
</ul>
</div>
</li>
<li><a id="org5f6736c"></a>Challenges and Learnings<br />
<div class="outline-text-6" id="text-1-3-5-3-3">
<p>
Developing this debugger presented several challenges:
</p>


<ol class="org-ol">
<li>Understanding the intricacies of process control and the ptrace system call.</li>
<li>Mapping C concepts and functinos to their Rust equivalents.</li>
<li>Implementing a robust command parsing and handling system.</li>
</ol>

<p>
However, shese challenges provided valuable learning experiences. I gained a deeper understanding of:
</p>

<ul class="org-ul">
<li>Low-level system interactions in Rust</li>
<li>The architecture of debugging tools</li>
<li>Effective use of Rust crates to simplify complex tasks</li>
</ul>
</div>
</li>
</ol>
</li>
</ol>
</div>
</div>
<div id="outline-container-org6b1d144" class="outline-3">
<h3 id="org6b1d144"><span class="section-number-3">1.4.</span> Conclusion</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Creating a debugger in Rust for Linux programs has been an enlightening journey. It has deepened my understanding of both Rust and the underlying mechanics of debugging tools. The project showcases the power of Rust in systems programming, demonstrating how it can be used to create robust, safe, and efficient tools for low-level system interactions.
</p>

<p>
This experience has not only improved my Rust programming skills but also given me a newfound appreciation for the complexity and ingenuity behind the development tools we use every day.
</p>
</div>
</div>
<div id="outline-container-org9c682ff" class="outline-3">
<h3 id="org9c682ff"><span class="section-number-3">1.5.</span> References</h3>
<div class="outline-text-3" id="text-1-5">
<p>
<a href="https://blog.tartanllama.xyz/writing-a-linux-debugger-setup/">Writing a linux debugger setup</a>
</p>

<p>
<a href="https://docs.rs/nix/latest/nix/index.html">nix crate documentation</a>
</p>

<p>
<a href="https://docs.rs/strum/latest/strum/">strum crate documentation</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2025-01-02 Thu 05:26</p>
</div>
</body>
</html>
