#+SETUPFILE: ./org-html-themes/org/theme-readtheorg.setup
* How I wrote the vdebugger, a debugger in Rust for Linux Programs ?

As a passionate developer always looking to expand my skills, I recently embarked on an exciting project: creating a debugger in Rust for Linux programs. This article chronicles my journey, from setting up a reproducible development environment to implementing the core functionality of the debugger.

You can check the project at : [[https://github.com/SamuelVanie/vdebugger][the vdebugger repo]]


** Setting Up the Development Environment

I began by creating a robust and reproducible development environment using Nix.
Here's how I set it up...

It's a classic flake.nix file that contains

1. ~flake-utils~ to automatically generate outputs and devShells for various systems
2. Employed ~rust-overlay~ to pull the latest Rust version directly.

That's all ! The final nix file looks like this :

#+begin_src nix
{
  description = "A nix file for my homemade debugger";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-24.05";
    flake-utils.url = "github:numtide/flake-utils";
    rust-overlay.url = "github:oxalica/rust-overlay";
  };

  outputs = { self, nixpkgs, flake-utils, rust-overlay, ... }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        overlays = [ (import rust-overlay) ];
        pkgs = import nixpkgs { inherit system overlays; };
        rustVersion = pkgs.rust-bin.stable.latest.default;

        rustPlatform = pkgs.makeRustPlatform {
          cargo = rustVersion;
          rustc = rustVersion;
        };

        vdebuggerBuild = rustPlatform.buildRustPackage {
          pname = "vdebugger";
          version = "0.1.0";
          src = ./.;
          cargoLock.lockFile = ./Cargo.lock;
        };

      in
      {
        defaultPackage = vdebuggerBuild;

        devShell = pkgs.mkShell {
          buildInputs = [ (rustVersion.override { extensions = [ "rust-src" ]; }) ];
        };

      });
}
#+end_src

To run the project and start programming I simply the command ~nix develop~ that permits to access my devShell.


** Laying the Groundwork

With the environment ready, I dove into the core concepts of debugger development. I quickly realized that a debugger operates as a parent process controlling a child process(the debugee). This led me to search for a Rust crate that could provide functionality similar to the C ~fork()~ system call.

My search led me to the ~nix~ crate, which offers Rust bindings for many POSIX APIs, including most C system call functions. This crate became instrumental in my project


** Implementing Basic Debugger Functionality

*** Process Creation and Control

In my main function, I implemented the following steps:

1. Created a new process using the ~fork()~ function from the ~nix~ crate.
2. Used the ~traceme()~ function (equivalent to the ~ptrace(PTRACE_TRACEME, ...)~ in C) to permit to the parent function to trace the child.
3. Executed the program to be debugged in the child process using the ~execv()~ function.

   
*** The Debugger Struct

To organize the debugger's functionality and have a better management of the parent process flow, I created a ~Debugger~ struct. The fields of this struct are :
- ~m_prog_name~: The name of the program being debugged
- ~m_pid~ : The process ID of the child process we're controlling

  
*** The Run Function

The heart of our debugger is the ~run~ function. Here's how it operates:

1. It waits for the child process to start using the ~waitpid~ function from the ~nix~ crate.
   This ensures that we don't begin debugging until the child process is ready.
   
2. Once the child process is running, it creates a command-line prompt using the ~linefeed~ crate. This crate not only handles user input but also provides history functionality, enhancing the user experience.


*** Command Handling

To manage the various debugging commands, I implemented the following system:

1. Created an enum called ~Command~ with variants representing different debugging actions (e.g., continue, step, breakpoint).
2. Utilized the ~strum_macros~ crate to easily translate string input from the prompt into the corresponding ~Command~ variant.
3. Implemented a ~handle_command~ function that:
   - Attempts to parse the user input into a ~Command~ variant
   - If successful, calls the appropriate functino for that command
   - If the input doesn't match any know command, it informs the user that the command doesn't exist

This approach provides a flexible and extensible way to add new debugging commands in the future.


*** Implementing Commands

**** Continue

When the user enters the "continue" command, ~handle_command~ recognizes it and calls the ~continue~ command. The continue function uses the ~cont~ function from the nix crate to send a CONTINUE instruction to the debuggee program with its pid.

This allows the debugged program to continue execution until the next breakpoint or until it terminates.


**** break

Will come soon...


*** Challenges and Learnings

Developing this debugger presented several challenges:

1. Understanding the intricacies of process control and the ptrace system call.
2. Mapping C concepts and functinos to their Rust equivalents.
3. Implementing a robust command parsing and handling system.

However, shese challenges provided valuable learning experiences. I gained a deeper understanding of:

- Low-level system interactions in Rust
- The architecture of debugging tools
- Effective use of Rust crates to simplify complex tasks



** Conclusion

Creating a debugger in Rust for Linux programs has been an enlightening journey. It has deepened my understanding of both Rust and the underlying mechanics of debugging tools. The project showcases the power of Rust in systems programming, demonstrating how it can be used to create robust, safe, and efficient tools for low-level system interactions.

This experience has not only improved my Rust programming skills but also given me a newfound appreciation for the complexity and ingenuity behind the development tools we use every day.


** References

[[https://blog.tartanllama.xyz/writing-a-linux-debugger-setup/][Writing a linux debugger setup]]

[[https://docs.rs/nix/latest/nix/index.html][nix crate documentation]]

[[https://docs.rs/strum/latest/strum/][strum crate documentation]]
